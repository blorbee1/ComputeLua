[{"title":"About","type":0,"sectionRef":"#","url":"/ComputeLua/docs/intro","content":"","keywords":""},{"title":"Why Use ComputeLua?​","type":1,"pageTitle":"About","url":"/ComputeLua/docs/intro#why-use-computelua","content":""},{"title":"Fully Typed​","type":1,"pageTitle":"About","url":"/ComputeLua/docs/intro#fully-typed","content":"ComputeLua has typing for functions, classes, everything. Every type will be also checked and will throw an error if it is the incorrect type, so double check your types. "},{"title":"Big Computing Projects​","type":1,"pageTitle":"About","url":"/ComputeLua/docs/intro#big-computing-projects","content":"ComputeLua will allow you to create workers that will repeat the same small task all in parallel. It will then compile all the data the workers made into one table and return it back to you to use in the main thread! Wave/Ocean simulationEditable mesh generationTerrain generation These all require a lot of small information to be processsed very quickly and that is exactly what doing things in parallel does. "},{"title":"Developer Friendly​","type":1,"pageTitle":"About","url":"/ComputeLua/docs/intro#developer-friendly","content":"ComputeLua may be a bit complex to a newcomer, but the design of the library was made keeping in mind of the ease of use. "},{"title":"Dispatcher","type":0,"sectionRef":"#","url":"/ComputeLua/api/Dispatcher","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#types","content":" "},{"title":"BufferDataType​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#BufferDataType","content":"&lt;/&gt; type BufferDataType = Vector2 | Vector3 | CFrame | Color3 | UDim | UDim2 | number | boolean | string The only data types allowed in buffers, Compute or Variable  "},{"title":"VariableBufferDataType​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#VariableBufferDataType","content":"&lt;/&gt; type VariableBufferDataType = {[number]: BufferDataType} Type for the data of the VariableBuffer "},{"title":"Properties​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#properties","content":" "},{"title":"numWorkers​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#numWorkers","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Dispatcher.numWorkers: number How many workers this Dispatcher has "},{"title":"Functions​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#functions","content":" "},{"title":"Dispatch​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#Dispatch","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; Dispatcher.Dispatch( self: Dispatcher, numThreads: number,-- How many workers will be invoked to run their code. If using serial dispatch, this cannot exceed the number of workers. Try to match the size of data you are going to process if you are not using a serial dispatch. thread: string,-- The name of the thread to dispatch, this is the same name as the one in the workers useSerialDispatch: boolean?-- NOT RECOMMENDED UNLESS YOU KNOW WHAT YOU ARE DOING Default to 'true'. This will cause every worker to only be called once. ) → Promise Dispatch a number of threads to the workers  "},{"title":"SetVariableBuffer​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#SetVariableBuffer","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; Dispatcher.SetVariableBuffer( self: Dispatcher, bufferData: VariableBufferDataType-- The data to set the variable buffer to. ) → () Set the data of the SetVariableBuffer for this Dispatcher. Be careful to only call this when no workers are working  "},{"title":"Destroy​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/api/Dispatcher#Destroy","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; Dispatcher.Destroy(self: Dispatcher) → () The cleanup function for a Dispatcher. This is important to call to free up memory "},{"title":"Dispatcher","type":0,"sectionRef":"#","url":"/ComputeLua/docs/dispatcher","content":"","keywords":""},{"title":"Creating a Dispatcher​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/docs/dispatcher#creating-a-dispatcher","content":"To create a Dispatcher you will just need to call ComputeLua.CreateDispatcher() with the correct arguments. This will return a Dispatcher which can be used to dispatch a thread or update the Variable Buffer. Dispatcher:SetVariableBuffer() This will set the Variable Buffer's data. Make sure your table's data matchs the allowed data types or it will throw an error. This should be called before the Dispatcher is dispatched. If it is called while the workers are working, then you may lose data or the workers will be unable to work correctly. note The Variable Buffer's data is a read-only table. If you try to manually modify it within a worker or a non-worker (outside the Dispatcher:SetVariableBuffer() method), it will throw an error.  "},{"title":"Dispatching Threads​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/docs/dispatcher#dispatching-threads","content":"Dispatching a thread is very simple. All you need to do is call Dispatcher:Dispatch() with the correct arguments. This will return a Promise so you can process that Promise as you please. Once the Promise is resolved, then it is safe to get the data from the Compute Buffers if you have any. Before the Promise is resolved, that you may get unfinished data or just the original data.  "},{"title":"Example​","type":1,"pageTitle":"Dispatcher","url":"/ComputeLua/docs/dispatcher#example","content":"local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local workerTemplate = script.Worker local numWorkers = 128 -- I want to have a total worker count of 128 local ComputeLua = require(ReplicatedStorage.ComputeLua) local Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate) local PositionBuffer = ComputeLua.CreateComputeBuffer(&quot;PositionBuffer&quot;) local startingData = table.create(64, Vector3.zero) -- This will precreate a table with 64 elements all with Vector3.zero as the value PositionBuffer:SetData(startingData) Dispatcher:Dispatch(64, &quot;CalculatePositions&quot;):andThen(function() local data = PositionBuffer:GetData() -- Get the data back from the PositionBuffer which should have all the new positions print(&quot;Starting data:&quot;) print(startingData) print(&quot;Resulting data:&quot;) print(data) end)  "},{"title":"Compute Buffer","type":0,"sectionRef":"#","url":"/ComputeLua/docs/computebuffer","content":"","keywords":""},{"title":"Creating a Compute Buffer​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#creating-a-compute-buffer","content":"To create a Compute Buffer you will just need to call ComputeLua.CreateComputeBuffer() with the correct arguments. This will return a ComputeBuffer which can be used to get the complied data and set the data to send over the workers. ComputeBuffer:SetData() This will set the Compute Buffer's data. Make sure your table's data matchs the allowed data types or it will throw an error. This should be called before the Dispatcher is dispatched. If it is called while the workers are working, then you may lose data or the workers will be unable to work correctly.ComputeBuffer:GetData() This will get the data from the Compute Buffer. This should be called after the Dispatcher has dispatched all its threads and the workers have finished otherwise you may get unfinished data. caution The Compute Buffer's data is a read-only table. If you try to manually modify it within a worker or a non-worker (outside the ComputeBuffer:SetData() method), it will throw an error. Compute Buffers are global Compute Buffers ignore Dispatchers. If you have the same name for two Compute Buffers but different areas and Dispatchers, that doesn't matter it will pick the data and set the data of whatever Compute Buffer was made/edited last.  "},{"title":"Common Practices​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#common-practices","content":"You should keep your Compute Buffers simple, remove nested tables and make everything on the same level. Nested tables will take longer to write to, so keep it short and simple. Here is an example of how you can convert your nested tables, or tables with non valid keys, into un-nested/safe tables. -- This table is unsafe due to it using a string key (&quot;key1&quot;, &quot;key2&quot;, etc). The keys must be a number which is just a regular array local unsafeTable = { { key1 = true, key2 = &quot;hello&quot;, key3 = 5182 }, { key1 = true, key2 = &quot;hello&quot;, key3 = 5182 }, { key1 = true, key2 = &quot;hello&quot;, key3 = 5182 }, { key1 = true, key2 = &quot;hello&quot;, key3 = 5182 }, } local stride = 3 -- This number is how many indices your nested table takes up. For this example, that is three elements local data = {} -- This will take everything within the unsafeTable and convert it to being safe (removing the string keys) for _, v in pairs(unsafeTable) do table.insert(data, v.key1) table.insert(data, v.key2) table.insert(data, v.key3) end print(data) -- Your compiled safe and non-nested data table  The worker scripts can use their dispatch ID to index the Compute Buffers' data to figure out the exact data they are working with. Therefore if you have a lot of data to edit, such as positions for some terrain generation, then if you store them in one list and send them in a Compute Buffer you will be able to use the dispatch ID to find the exact data to edit. Another important issue is Compute Buffers will be usually used for lots of data. So if you give the workers a dynamic table (one that has nothing in it and will resize itself when new values are put into it) then the workers will work very slowly since resizing a table, especially a SharedTable, takes time. For this reason, you should precreate all the data you are going to put into a Compute Buffer, even if the workers will not read anything from the table you at least should put some template value like '0' local data = table.create(5000, Vector3.zero) -- This will precreate a table of 5000 entries with a zero-ed out Vector3 at each one. PositionBuffer:SetData(data)  Functions cannot be sent to the workers You cannot send functions to workers through a Compute Buffer or Variable Buffer. Therefore you will have to have the function on the worker script and then send the values required to run the function through a Compute Buffer or Variable Buffer.  "},{"title":"Getting the data​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#getting-the-data","content":"ComputeBuffer:GetData() and ComputeLua.GetComputeBufferData() will return a SharedTable. The SharedTable means that there is a different way to iterate through the table. You can no longer use ipairs or pairs, you must use in table to iterate through it. But theres a catch, Roblox will shallow clone the SharedTable whenever you iterate through it; therefore no edits you make to it will apply. Due to this, if you need to loop through a Compute Buffer's data in a worker; you should supply the size of the table in the Variable Buffers so you can use a range loop. caution ComputeBuffer:GetData() returns a read-only table. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua) ComputeLua.CreateThread(actor, &quot;ThreadName&quot;, function(id, variableBuffer) local bufferData = ComputeLua.GetComputeBufferData(&quot;ComputeBuffer&quot;) local bufferSize = variableBuffer[1] for i = 1, bufferSize do -- Since I'm using a range loop, I am able to make changes to the data and have it update the table bufferData[i] = 5 end for i, v in bufferData do -- Since this is a 'in' loop, any edits will not apply to the bufferData bufferData[i] = 10 end end) -- What gets returned to the Dispatcher: -- All bufferData values equal 5   "},{"title":"Examples​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#examples","content":""},{"title":"Load in a list of vertices​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#load-in-a-list-of-vertices","content":"local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local workerTemplate = script.Worker local numWorkers = 240 -- 4 * 60 local ComputeLua = require(ReplicatedStorage.ComputeLua) local Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate) local PositionBuffer = ComputeLua.CreateComputeBuffer(&quot;PositionBuffer&quot;) local numVertices = 10000 local vertices = table.create(numVertices, Vector3.zero) -- Create a table of 10000 entries all with Vector3.zero PositionBuffer:SetData(vertices) Dispatcher:Dispatch(numVertices, &quot;CalculatePositions&quot;):andThen(function() local vertices = PositionBuffer:GetData() -- Get the positions back from the workers for _, pos in vertices do editableMesh:AddVertex(pos) -- Add the vertex position to the mesh end end)  "},{"title":"Get the height for some terrain noise​","type":1,"pageTitle":"Compute Buffer","url":"/ComputeLua/docs/computebuffer#get-the-height-for-some-terrain-noise","content":"local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local workerTemplate = script.Worker local numWorkers = 240 -- 4 * 60 local ComputeLua = require(ReplicatedStorage.ComputeLua) local Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate) local HeightBuffer = ComputeLua.CreateComputeBuffer(&quot;HeightBuffer&quot;) local numHeights = 10000 local heights = table.create(numHeights, 0) -- Create a table of 10000 entries all with 0 HeightBuffer:SetData(heights) Dispatcher:Dispatch(numVertices, &quot;CalculatePositions&quot;):andThen(function() local heights = HeightBuffer:GetData() -- Get the heights back from the workers for _, height in heights do print(height) -- Print the height end end)  "},{"title":"ComputeBuffer","type":0,"sectionRef":"#","url":"/ComputeLua/api/ComputeBuffer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#types","content":" "},{"title":"BufferDataType​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#BufferDataType","content":"&lt;/&gt; type BufferDataType = Vector2 | Vector3 | CFrame | Color3 | UDim | UDim2 | number | boolean | string The only data types allowed in buffers, Compute or Variable  "},{"title":"ComputeBufferDataType​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#ComputeBufferDataType","content":"&lt;/&gt; type ComputeBufferDataType = {[number]: BufferDataType | ComputeBufferDataType} Type for the data of a ComputeBuffer "},{"title":"Properties​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#properties","content":" "},{"title":"name​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ComputeBuffer.name: string The name of the buffer. "},{"title":"Functions​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#functions","content":" "},{"title":"GetData​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#GetData","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; ComputeBuffer.GetData(self: ComputeBuffer) → ComputeBufferDataType-- The data of the buffer, a read-only table Get the data of the ComputeBuffer  "},{"title":"SetData​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#SetData","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; ComputeBuffer.SetData( self: ComputeBuffer, bufferData: ComputeBufferDataType-- The data to set the buffer with, only certain data types are allowed. ) → () Set the data of the ComputeBuffer. Be careful to only call this when no workers are working  "},{"title":"Clean​","type":1,"pageTitle":"ComputeBuffer","url":"/ComputeLua/api/ComputeBuffer#Clean","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; ComputeBuffer.Clean(self: ComputeBuffer) → () The cleanup function for a ComputeBuffer. This is important to call to free up memory "},{"title":"ComputeLua","type":0,"sectionRef":"#","url":"/ComputeLua/api/ComputeLua","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#types","content":" "},{"title":"BufferDataType​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#BufferDataType","content":"&lt;/&gt; type BufferDataType = Vector2 | Vector3 | CFrame | Color3 | UDim | UDim2 | number | boolean | string The only data types allowed in buffers, Compute or Variable  "},{"title":"ComputeBufferDataType​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#ComputeBufferDataType","content":"&lt;/&gt; type ComputeBufferDataType = {[number]: BufferDataType | ComputeBufferDataType} Type for the data of a ComputeBuffer  "},{"title":"VariableBufferDataType​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#VariableBufferDataType","content":"&lt;/&gt; type VariableBufferDataType = {[number]: BufferDataType} Type for the data of the VariableBuffer "},{"title":"Functions​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#functions","content":" "},{"title":"CreateDispatcher​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#CreateDispatcher","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; ComputeLua.CreateDispatcher( numWorkers: number,-- How many workers to use, balanced this with performance and speed worker: Script | LocalScript -- The template script to clone as the worker ) → Dispatcher Create a Dispatcher to run a bunch of workers in parallel  "},{"title":"CreateComputeBuffer​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#CreateComputeBuffer","content":"Parallel Unsafe since v1.0.0 &lt;/&gt; ComputeLua.CreateComputeBuffer( bufferName: string-- The name of the buffer. ) → ComputeBuffer Create a ComputeBuffer to store vital information that is then sent to each worker.  "},{"title":"GetComputeBufferData​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#GetComputeBufferData","content":"Serial Unsafe since v1.0.0 &lt;/&gt; ComputeLua.GetComputeBufferData( bufferName: string-- The name of the buffer. ) → ComputeBufferDataType-- The data of the ComputeBuffer Get the ComputeBuffer data  "},{"title":"CreateThread​","type":1,"pageTitle":"ComputeLua","url":"/ComputeLua/api/ComputeLua#CreateThread","content":"Serial Unsafe since v1.1.0 &lt;/&gt; ComputeLua.CreateThread( actor: Actor ,-- The Actor to bind the thread to, this should be the same actor as the parent of the worker. threadName: string,-- The unique name of the thread. callback: ( dispatchId: number, variableBuffer: VariableBufferDataType ) → ()-- The function that will be executed when the thread is called ) → () Create a thread for the Dispatcher to execute "},{"title":"Worker","type":0,"sectionRef":"#","url":"/ComputeLua/docs/worker","content":"","keywords":""},{"title":"Creating a Worker​","type":1,"pageTitle":"Worker","url":"/ComputeLua/docs/worker#creating-a-worker","content":"To create a worker script, disable it so it doesn't run without the Dispatcher cloning it, you just create a new script and pass in that script into the ComputeLua.CreateDispatcher() method as the worker template in whatever script is running the Dispatchers. This will automatically clone the workers the Dispatcher needs and enable them. Worker parent is the template The Dispatcher will automatically parent the workers to the worker template. So wherever the worker template is should be a spot where that script can run. The basic layout of a worker script is: Check if this script has an actorRequire ComputeLuaCreate the threads local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua)   "},{"title":"Creating a Thread​","type":1,"pageTitle":"Worker","url":"/ComputeLua/docs/worker#creating-a-thread","content":"To create a thread you simply call ComputeLua.CreateThread() with the correct arguments. This will connect a new thread so the Dispatcher knows what function to call when invoking this worker. The thread name should be unique to prevent overlapping functions. The CreateThread method's last argument is the callback. This is the function that will run for every worker that gets executed. It takes in two parameters, the dispatch ID and the Variable Buffer. You should keep your Compute Buffers simple, remove nested tables and make everything on the same level. Nested tables will take longer to write to, so keep it short and simple. ComputeLua.CreateThread(actor, &quot;ThreadName&quot;, function(id, variableBuffer) end)  The dispatch ID (id) is the current ID of the worker, this starts at 1 and ends at how many threads that the Dispatcher is executing. The Variable Buffer (variableBuffer) is the data of the Variable Buffer you assigned to the Dispatcher. The Variable Buffer is read-only If you attempt to edit the Variable Buffer, it will throw an error.  "},{"title":"Getting Compute Buffer data​","type":1,"pageTitle":"Worker","url":"/ComputeLua/docs/worker#getting-compute-buffer-data","content":"ComputeLua.GetComputeBufferData() is the way to get the data of a Compute Buffer, it takes in the name of the buffer. ComputeLua.GetComputeBufferData() will return a SharedTable. The SharedTable means that there is a different way to iterate through the table. You can no longer use ipairs or pairs, you must use in table to iterate through it. But theres a catch, Roblox will shallow clone the SharedTable whenever you iterate through it; therefore no edits you make to it will apply. Due to this, if you need to loop through a Compute Buffer's data in a worker; you should supply the size of the table in the Variable Buffers so you can use a range loop. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua) ComputeLua.CreateThread(actor, &quot;ThreadName&quot;, function(id, variableBuffer) local bufferData = ComputeLua.GetComputeBufferData(&quot;ComputeBuffer&quot;) local bufferSize = variableBuffer[1] for i = 1, bufferSize do -- Since I'm using a range loop, I am able to make changes to the data and have it update the table bufferData[i] = 5 end for i, v in bufferData do -- Since this is a 'in' loop, any edits will not apply to the bufferData bufferData[i] = 10 end end) -- What gets returned to the Dispatcher: -- All bufferData values equal 5  You can use the dispatch ID to easily access the current data the current worker instance is working on. All you do is just index the Compute Buffer's data with the dispatch ID and you will get the data the worker is working on. tip If the number of threads executed is greater than the size of the data of the Compute Buffer, then the workers may receive nil data near the end of the execution  "},{"title":"Example : Apply noise to positions​","type":1,"pageTitle":"Worker","url":"/ComputeLua/docs/worker#example--apply-noise-to-positions","content":"local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua) ComputeLua.CreateThread(actor, &quot;CalculatePositions&quot;, function(id, variableBuffer) local PositionBuffer = ComputeLua.GetComputeBufferData(&quot;PositionBuffer&quot;) local numPositions = variableBuffer[1] -- Get the first index of the variable buffer, which in this case is the size of the PositionBuffer for i = 1, numPositions do local position = PositionBuffer[i] PositionBuffer[i] = math.nosie(position.x, position.y, position.z) end end)  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/ComputeLua/docs/gettingstarted","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#install","content":"Install ComputeLua directly from Roblox. Then, place it into ReplicatedStorage so both the Server and Client can access it.  "},{"title":"Basic Setup​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#basic-setup","content":"The first thing you always do with any library, is require the module. So, let's require it. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local ComputeLua = require(ReplicatedStorage.ComputeLua)  "},{"title":"Creating a Dispatcher​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#creating-a-dispatcher","content":"Without a Dispatcher nothing will run, so this is pretty important. A Dispatcher's whole job is to handle a lot of workers and execute their threads. It will manage all of this so you don't have to. You can create a Dispatcher by called the ComputeLua.CreateDispatcher() method. This method will take in two parameters. numWorkers -- How many workers do you want this Dispatcher to handle? This will vary depending on your needs, but it is recommended to pick a number that is a multiple of 4.worker -- The template of the worker script, this is what will be running the threads you create. You are going to need a worker template, so, for now, let's create a blank script and place it as a child of the current script. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local workerTemplate = script.Worker local numWorkers = 64 local ComputeLua = require(ReplicatedStorage.ComputeLua) local Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate)  caution Workers will be parented under their template when they are created by the Dispatcher. Make sure they are able to run in their current location.  "},{"title":"Compute Buffers​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#compute-buffers","content":"Compute Buffers are just a large table of items that are sent over to the workers so they can edit them and send them back. This is how you can send data back and forth between the main thread and the workers. To create a Compute Buffer, all you need to call is the ComputeLua.CreateComputeBuffer() method. This method takes in one parameter. bufferName -- What is the name of this buffer? It should be unique to prevent data loss when getting the data back. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local ComputeLua = require(ReplicatedStorage.ComputeLua) local PositionBuffer = ComputeLua.CreateComputeBuffer(&quot;PositionBuffer&quot;)  Next you would want to set the data of the Compute Buffer. You can set the data of the buffer by running ComputeBuffer:SetData(). This takes in one parameter. bufferData -- A table of the data you want to set this buffer to have. Compute Buffers can only have certain data types Buffer data is limited due to limitations in Roblox First, the keys of the data must only be numbers, this will allow fast and effective sending of the data.Second, the only data types allowed for the data are: Vector2Vector3 CFrame Color3 UDim UDim2 number boolean stringTable containing any of these (nested tables) -- Allowed { 15, Vector3.zero, false, &quot;string&quot;, CFrame.new(), { Vector3.new(0, 2, 1) }, [7] = &quot;sfas&quot; } -- Not allowed { stringKey = 1512, function() end }  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local ComputeLua = require(ReplicatedStorage.ComputeLua) local PositionBuffer = ComputeLua.CreateComputeBuffer(&quot;PositionBuffer&quot;) PositionBuffer:SetData({ Vector3.zero, Vector3.new(5, 1, 2), Vector3.yAxis, Vector3.zAxis })  Finally, you probably want the compiled data from the Compute Buffer after the Dispatcher has dispatched and the workers are finished. You can easily get this by running ComputeBuffer:GetData(). This will return a read-only table of all the data the workers have made together. local result = PositionBuffer:GetData()   "},{"title":"Variable Buffer​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#variable-buffer","content":"Just like Compute Buffers, there is a Variable Buffer. This is unique however, this buffer cannot be edited by any worker and it is passed in through the parameters of the thread callback function. You can use this buffer to set constant variables that the workers will need to be able to use, for example: Size of the mapSize of a Compute Buffer's dataConstant variable for a function To set the data of this Variable Buffer, you call Dispatcher:SetVariableBuffer(). This takes in one parameter bufferData - A table of the data you want to set this buffer to have. The Variable Buffer can only have certain data types The limited data types are exactly the same to Compute Buffers, except you cannot have nested tables with the Variable Buffer The Variable Buffer is not Compute Buffers The Variable Buffer was not made to act like a Compute Buffer. You should not place a lot of information into it (by a lot of information, I mean over 1,000 elements) Use a Compute Buffer if you need a lot of data sent over. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local workerTemplate = script.Worker local numWorkers = 64 local ComputeLua = require(ReplicatedStorage.ComputeLua) local Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate) Dispatcher:SetVariableBuffer({ 15, Vector3.zero, false, &quot;string&quot;, CFrame.new() })   "},{"title":"Worker Script​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#worker-script","content":"Worker scripts are very simple. Firstly, you will need to check if the current script is running in an actor. This is to make sure that this script can run in parallel. local actor = script:GetActor() if actor == nil then return end  After that, you want to require ComputeLua so you can access its functions. danger NEVER call the &quot;Parallel Unsafe&quot; functions within ComputeLua. This will either cause an error or break something local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua)  Finally, the last thing you need to do is create a thread. You can easily create a thread by running ComputeLua.CreateThread(). This takes in three parameters actor -- ComputeLua needs this to keep track of the workersthreadName -- This should be unique to prevent overlap.callback -- This is a function that is called when the thread is executed. It takes in two parameters. id -- This is the dispatch ID. You can easily use the dispatch ID to focus on one value within Compute Buffers.variableBuffer -- The read-only table which is the data from the Variable Buffer. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local actor = script:GetActor() if actor == nil then return end local ComputeLua = require(ReplicatedStorage.ComputeLua) ComputeLua.CreateThread(actor, &quot;CalculatePositions&quot;, function(id, variableBuffer) local value = variableBuffer[1] -- Get the first variable within the Variable Buffer end)   "},{"title":"Dispatching​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#dispatching","content":"Now it's time to execute your workers. You can do this my dispatching your Dispatcher by running Dispatcher:Dispatch(). This takes in two required arguments and one optional. numThreads -- How many workers will be invoked to run their code. If using serial dispatch, this cannot exceed the number of workers. Try to match the size of data you are going to process if you are not using a serial dispatch.thread -- The name of the thread to execute.useSerialDispatch -- (optional) Default to 'true' NOT RECOMMENDED UNLESS YOU KNOW WHAT YOU ARE DOING. This will cause every worker to only be called once. The Dispatch method will return a Promise. You can either await this promise, which will yield the current thread, or you could use :andThen() which will run the function passed after the Promise is resolved, this is what is recommended. Dispatcher:Dispatch(4, &quot;CalculatePositions&quot;):andThen(function() local data = PositionBuffer:GetData() print(&quot;starting data:&quot;) print({ Vector3.zero, Vector3.new(5, 1, 2), Vector3.yAxis, Vector3.zAxis }) print(&quot;resulting data:&quot;) print(data) end)   "},{"title":"Cleaning Up​","type":1,"pageTitle":"Getting Started","url":"/ComputeLua/docs/gettingstarted#cleaning-up","content":"Make sure to clean up your Compute Buffers and Dispactchers by calling their respective clean up function. This will free up all the memory they are using and get rid of all the worker script clones. Dispacther:Destroy() ComputeBuffer:Clean()  "}]