"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[570],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var u=r.createContext({}),s=function(e){var t=r.useContext(u),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(a),d=n,f=c["".concat(u,".").concat(d)]||c[d]||h[d]||o;return a?r.createElement(f,i(i({ref:t},p),{},{components:a})):r.createElement(f,i({ref:t},p))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:n,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},30150:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=a(87462),n=(a(67294),a(3905));const o={sidebar_position:5},i="Worker",l={unversionedId:"worker",id:"worker",title:"Worker",description:"A worker is a script that is cloned by the Dispatcher which will perform small tasks. It may not seem important at first but the Dispatcher will clone a lot of things and they will all run in parallel, allowing these small tasks to add up into one big tasks that would take several seconds or even minutes to calculated if it was running serially.",source:"@site/docs/worker.md",sourceDirName:".",slug:"/worker",permalink:"/ComputeLua/docs/worker",draft:!1,editUrl:"https://github.com/blorbee1/ComputeLua/edit/main/docs/worker.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"Compute Buffer",permalink:"/ComputeLua/docs/computebuffer"}},u={},s=[{value:"Creating a Worker",id:"creating-a-worker",level:2},{value:"Creating a Thread",id:"creating-a-thread",level:2},{value:"Getting Compute Buffer data",id:"getting-compute-buffer-data",level:2},{value:"Example : Apply noise to positions",id:"example--apply-noise-to-positions",level:2}],p={toc:s},c="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"worker"},"Worker"),(0,n.kt)("p",null,"A worker is a script that is cloned by the ",(0,n.kt)("a",{parentName:"p",href:"dispatcher"},"Dispatcher")," which will perform small tasks. It may not seem important at first but the Dispatcher will clone a lot of things and they will all run in parallel, allowing these small tasks to add up into one big tasks that would take several seconds or even minutes to calculated if it was running serially. "),(0,n.kt)("h2",{id:"creating-a-worker"},"Creating a Worker"),(0,n.kt)("p",null,"To create a worker script, you just create a new script and pass in that script into the ",(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.CreateDispatcher()")," method as the worker template in whatever script is running the Dispatchers."),(0,n.kt)("p",null,"Make sure to disable it so it doesn't run without the Dispatcher cloning it."),(0,n.kt)("p",null,"This will automatically clone the workers the Dispatcher needs and enable them."),(0,n.kt)("admonition",{title:"Worker parent is the template",type:"caution"},(0,n.kt)("p",{parentName:"admonition"},"The Dispatcher will automatically parent the workers to the worker template. So wherever the worker template is should be a spot where that script can run.")),(0,n.kt)("p",null,"The basic layout of a worker script is:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Check if this script has an actor"),(0,n.kt)("li",{parentName:"ul"},"Require ComputeLua"),(0,n.kt)("li",{parentName:"ul"},"Create the threads")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal actor = script:GetActor()\nif actor == nil then\n    return\nend\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\n')),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"creating-a-thread"},"Creating a Thread"),(0,n.kt)("p",null,"To create a thread you simply call ",(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.CreateThread()")," with the correct arguments. This will connect a new thread so the Dispatcher knows what function to call when invoking this worker. The thread name should be unique to prevent overlapping functions."),(0,n.kt)("p",null,"The CreateThread method's last argument is the callback. This is the function that will run for every worker that gets executed. It takes in two parameters, the dispatch ID and the Variable Buffer."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'ComputeLua.CreateThread(actor, "ThreadName", function(id, variableBuffer)\n    \nend)\n')),(0,n.kt)("p",null,"The dispatch ID (id) is the current ID of the worker, this starts at 1 and ends at how many threads that the Dispatcher is executing."),(0,n.kt)("p",null,"The Variable Buffer (variableBuffer) is the data of the Variable Buffer you assigned to the Dispatcher."),(0,n.kt)("admonition",{title:"The Variable Buffer is read-only",type:"caution"},(0,n.kt)("p",{parentName:"admonition"},"If you attempt to edit the Variable Buffer, it will throw an error.")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"getting-compute-buffer-data"},"Getting Compute Buffer data"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.GetComputeBufferData()")," is the way to get the data of a Compute Buffer, it takes in the name of the buffer."),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.GetComputeBufferData()")," will return a ",(0,n.kt)("strong",{parentName:"p"},"SharedTable"),". The SharedTable means that there is a different way to iterate through the table. You can no longer use ",(0,n.kt)("inlineCode",{parentName:"p"},"ipairs")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"pairs"),", you must use ",(0,n.kt)("inlineCode",{parentName:"p"},"in table")," to iterate through it. But theres a catch, Roblox will shallow clone the SharedTable whenever you iterate through it; therefore no edits you make to it will apply. Due to this, if you need to loop through a Compute Buffer's data in a worker; you should supply the size of the table in the Variable Buffers so you can use a range loop."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal actor = script:GetActor()\nif actor == nil then\n    return\nend\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\n\nComputeLua.CreateThread(actor, "ThreadName", function(id, variableBuffer)\n    local bufferData = ComputeLua.GetComputeBufferData("ComputeBuffer")\n    local bufferSize = variableBuffer[1]\n\n    for i = 1, bufferSize do\n        -- Since I\'m using a range loop, I am able to make changes to the data and have it update the table\n        bufferData[i] = 5\n    end\n\n    for i, v in bufferData do\n        -- Since this is a \'in\' loop, any edits will not apply to the bufferData\n        bufferData[i] = 10\n    end\nend)\n\n-- What gets returned to the Dispatcher:\n-- All bufferData values equal 5\n')),(0,n.kt)("p",null,"You can use the dispatch ID to easily access the current data the current worker instance is working on. All you do is just index the Compute Buffer's data with the dispatch ID and you will get the data the worker is working on."),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"If the number of threads executed is greater than the size of the data of the Compute Buffer, then the workers may receive ",(0,n.kt)("inlineCode",{parentName:"p"},"nil")," data near the end of the execution")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"example--apply-noise-to-positions"},"Example : Apply noise to positions"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal actor = script:GetActor()\nif actor == nil then\n    return\nend\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\n\nComputeLua.CreateThread(actor, "CalculatePositions", function(id, variableBuffer)\n    local PositionBuffer = ComputeLua.GetComputeBufferData("PositionBuffer")\n\n    local position = PositionBuffer[id]\n    PositionBuffer[id] = math.nosie(position.x, position.y, position.z)\nend)\n')))}h.isMDXComponent=!0}}]);