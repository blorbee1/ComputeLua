"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[975],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var u=r.createContext({}),s=function(e){var t=r.useContext(u),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(a),f=n,d=c["".concat(u,".").concat(f)]||c[f]||h[f]||o;return a?r.createElement(d,i(i({ref:t},p),{},{components:a})):r.createElement(d,i({ref:t},p))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=f;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:n,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}f.displayName="MDXCreateElement"},5909:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=a(87462),n=(a(67294),a(3905));const o={sidebar_position:4},i="Compute Buffer",l={unversionedId:"computebuffer",id:"computebuffer",title:"Compute Buffer",description:"A Compute Buffer is the way to send big bunches of data to the workers so they can process it and send it back.",source:"@site/docs/computebuffer.md",sourceDirName:".",slug:"/computebuffer",permalink:"/ComputeLua/docs/computebuffer",draft:!1,editUrl:"https://github.com/blorbee1/ComputeLua/edit/main/docs/computebuffer.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Dispatcher",permalink:"/ComputeLua/docs/dispatcher"},next:{title:"Worker",permalink:"/ComputeLua/docs/worker"}},u={},s=[{value:"Creating a Compute Buffer",id:"creating-a-compute-buffer",level:2},{value:"Common Practices",id:"common-practices",level:2},{value:"Getting the data",id:"getting-the-data",level:2},{value:"Examples",id:"examples",level:2},{value:"Load in a list of vertices",id:"load-in-a-list-of-vertices",level:3},{value:"Get the height for some terrain noise",id:"get-the-height-for-some-terrain-noise",level:3}],p={toc:s},c="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"compute-buffer"},"Compute Buffer"),(0,n.kt)("p",null,"A Compute Buffer is the way to send big bunches of data to the workers so they can process it and send it back."),(0,n.kt)("h2",{id:"creating-a-compute-buffer"},"Creating a Compute Buffer"),(0,n.kt)("p",null,"To create a Compute Buffer you will just need to call ",(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.CreateComputeBuffer()")," with the correct arguments. This will return a ComputeBuffer which can be used to get the complied data and set the data to send over the workers."),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ComputeBuffer:SetData()")," This will set the Compute Buffer's data. Make sure your table's data matchs the allowed data types or it will throw an error. This should be called before the Dispatcher is dispatched. If it is called while the workers are working, then you may lose data or the workers will be unable to work correctly."),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ComputeBuffer:GetData()")," This will get the data from the Compute Buffer. This should be called after the Dispatcher has dispatched all its threads and the workers have finished otherwise you may get unfinished data."),(0,n.kt)("admonition",{type:"caution"},(0,n.kt)("p",{parentName:"admonition"},"The Compute Buffer's data is a read-only table. If you try to manually modify it within a worker or a non-worker (outside the ",(0,n.kt)("inlineCode",{parentName:"p"},"ComputeBuffer:SetData()")," method), it will throw an error.")),(0,n.kt)("admonition",{title:"Compute Buffers are global",type:"danger"},(0,n.kt)("p",{parentName:"admonition"},"Compute Buffers ignore Dispatchers. If you have the same name for two Compute Buffers but different areas and Dispatchers, that doesn't matter it will pick the data and set the data of whatever Compute Buffer was made/edited last.")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"common-practices"},"Common Practices"),(0,n.kt)("p",null,"You should keep your Compute Buffers simple, remove nested tables and make everything on the same level. Nested tables will take longer to write to, so keep it short and simple."),(0,n.kt)("p",null,"Here is an example of how you can convert your nested tables, or tables with non valid keys, into un-nested/safe tables."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'-- This table is unsafe due to it using a string key ("key1", "key2", etc). The keys must be a number which is just a regular array\nlocal unsafeTable = {\n    {\n        key1 = true,\n        key2 = "hello",\n        key3 = 5182\n    },\n    {\n        key1 = true,\n        key2 = "hello",\n        key3 = 5182\n    },\n    {\n        key1 = true,\n        key2 = "hello",\n        key3 = 5182\n    },\n    {\n        key1 = true,\n        key2 = "hello",\n        key3 = 5182\n    },\n}\n\nlocal stride = 3 -- This number is how many indices your nested table takes up. For this example, that is three elements\nlocal data = {}\n\n-- This will take everything within the unsafeTable and convert it to being safe (removing the string keys)\nfor _, v in pairs(unsafeTable) do\n    table.insert(data, v.key1)\n    table.insert(data, v.key2)\n    table.insert(data, v.key3)\nend\n\nprint(data) -- Your compiled safe and non-nested data table\n')),(0,n.kt)("p",null,"The worker scripts can use their dispatch ID to index the Compute Buffers' data to figure out the exact data they are working with. Therefore if you have a lot of data to edit, such as positions for some terrain generation, then if you store them in one list and send them in a Compute Buffer you will be able to use the dispatch ID to find the exact data to edit."),(0,n.kt)("p",null,"Another important issue is Compute Buffers will be usually used for lots of data. So if you give the workers a dynamic table (one that has nothing in it and will resize itself when new values are put into it) then the workers will work very slowly since resizing a table, especially a SharedTable, takes time."),(0,n.kt)("p",null,"For this reason, you should precreate all the data you are going to put into a Compute Buffer, even if the workers will not read anything from the table you at least should put some template value like '0'"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"local data = table.create(5000, Vector3.zero) -- This will precreate a table of 5000 entries with a zero-ed out Vector3 at each one.\nPositionBuffer:SetData(data)\n")),(0,n.kt)("admonition",{title:"Functions cannot be sent to the workers",type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"You cannot send functions to workers through a Compute Buffer or Variable Buffer. Therefore you will have to have the function on the worker script and then send the values required to run the function through a Compute Buffer or Variable Buffer.")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"getting-the-data"},"Getting the data"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ComputeBuffer:GetData()")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"ComputeLua.GetComputeBufferData()")," will return a ",(0,n.kt)("strong",{parentName:"p"},"SharedTable"),". The SharedTable means that there is a different way to iterate through the table. You can no longer use ",(0,n.kt)("inlineCode",{parentName:"p"},"ipairs")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"pairs"),", you must use ",(0,n.kt)("inlineCode",{parentName:"p"},"in table")," to iterate through it. But theres a catch, Roblox will shallow clone the SharedTable whenever you iterate through it; therefore no edits you make to it will apply. Due to this, if you need to loop through a Compute Buffer's data in a worker; you should supply the size of the table in the Variable Buffers so you can use a range loop."),(0,n.kt)("admonition",{type:"caution"},(0,n.kt)("p",{parentName:"admonition"},(0,n.kt)("inlineCode",{parentName:"p"},"ComputeBuffer:GetData()")," returns a ",(0,n.kt)("strong",{parentName:"p"},"read-only")," table.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal actor = script:GetActor()\nif actor == nil then\n    return\nend\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\n\nComputeLua.CreateThread(actor, "ThreadName", function(id, variableBuffer)\n    local bufferData = ComputeLua.GetComputeBufferData("ComputeBuffer")\n    local bufferSize = variableBuffer[1]\n\n    for i = 1, bufferSize do\n        -- Since I\'m using a range loop, I am able to make changes to the data and have it update the table\n        bufferData[i] = 5\n    end\n\n    for i, v in bufferData do\n        -- Since this is a \'in\' loop, any edits will not apply to the bufferData\n        bufferData[i] = 10\n    end\nend)\n\n-- What gets returned to the Dispatcher:\n-- All bufferData values equal 5\n')),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"examples"},"Examples"),(0,n.kt)("h3",{id:"load-in-a-list-of-vertices"},"Load in a list of vertices"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal workerTemplate = script.Worker\nlocal numWorkers = 240 -- 4 * 60\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\nlocal Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate)\n\nlocal PositionBuffer = ComputeLua.CreateComputeBuffer("PositionBuffer")\n\nlocal numVertices = 10000\nlocal vertices = table.create(numVertices, Vector3.zero) -- Create a table of 10000 entries all with Vector3.zero\nPositionBuffer:SetData(vertices)\n\nDispatcher:Dispatch(numVertices, "CalculatePositions"):andThen(function()\n    local vertices = PositionBuffer:GetData() -- Get the positions back from the workers\n    for _, pos in vertices do\n        editableMesh:AddVertex(pos) -- Add the vertex position to the mesh\n    end\nend)\n')),(0,n.kt)("h3",{id:"get-the-height-for-some-terrain-noise"},"Get the height for some terrain noise"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal workerTemplate = script.Worker\nlocal numWorkers = 240 -- 4 * 60\n\nlocal ComputeLua = require(ReplicatedStorage.ComputeLua)\nlocal Dispatcher = ComputeLua.CreateDispatcher(numWorkers, workerTemplate)\n\nlocal HeightBuffer = ComputeLua.CreateComputeBuffer("HeightBuffer")\n\nlocal numHeights = 10000\nlocal heights = table.create(numHeights, 0) -- Create a table of 10000 entries all with 0\nHeightBuffer:SetData(heights)\n\nDispatcher:Dispatch(numVertices, "CalculatePositions"):andThen(function()\n    local heights = HeightBuffer:GetData() -- Get the heights back from the workers\n    for _, height in heights do\n        print(height) -- Print the height\n    end\nend)\n')))}h.isMDXComponent=!0}}]);